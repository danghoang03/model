{
    "Data Structures and Algorithms": {
        "Chap 1: Introduction": {
            "What is Data?": "Data is information that has been translated into a form that is more convenient to calculate, analyze. Qualitative data: descriptive information, Quantitative data: numerical information (numbers). Discrete data can only take certain values (like whole numbers). Continuous data can take any value (within a range)",
            "Data Type": "Class of data objects that have the same properties. 1. A set of values. 2. A set of operations on values. Type: Integer, Floating point, character,...",
            "Data Stuctures": "What is a data structure? 1. A combination of elements in which each is either a data type or another data structure. 2. A set of associations or relationships (structure) that holds the data together.",
            "Abstract data type": "The concept of abstraction: Users know what a data type can do. How it is done is hidden. Denition: An abstract data type is a data declaration packaged together with the operations that are meaningful for the data type. 1. Declaration of data. 2. Declaration of operations. 3. Encapsulation of data and operations",
            "Algorithm": "What is an algorithm? The logical steps to solve a problem. What is a program? Program = Data structures + Algorithms.",
            "Pseudocode": "The most common tool to dene algorithms. English-like representation of the algorithm logic. Pseudocode = English + code. English: relaxed syntax being easy to read. Code: instructions using basic control structures (sequential, conditional, iterative). Algorithm Header: Name, Parameters and their types. Purpose: what the algorithm does. Precondition: precursor requirements for the parameters. Postcondition: taken action and status of the parameters. Return condition: returned value. Algorithm Body: Statements. Statement numbers: decimal notation to express levels. Variables: important data. Algorithm analysis: comments to explain salient points. Statement constructs: sequence, selection, iteration.",
            "Pointers": "A pointer is a variable whose value is the address of another variable, i.e., direct address of the memory location. Address-of operator (&): The address of a variable can be obtained by preceding the name of a variable with an ampersand sign (&), known as address-of operator. Dereference operator (*): To access the variable pointed to by a pointer, we precede the pointer name with the dereference operator (*).",
            "Arrays": "An array is a series of elements of the same type placed in contiguous memory locations that can be individually referenced by a unique identier with an index.",
            "Pointers and arrays": "The concept of arrays is related to that of pointers. Arrays work very much like pointers to their rst elements, and, actually, an array can always be implicitly converted to the pointer of the proper type."
        },
        "Chap 2: Algorithm Complexity": {
            "Algorithm Eciency": "A problem often has many algorithms. Comparing two dierent algorithms ⇒ Computational complexity: measure of the diculty degree (time and/or space) of an algorithm. How fast an algorithm is? How much memory does it cost? General format eciency = f(n), n is the size of a problem (the key number that determines the size of input data)",
            "Asymptotic Complexity": "Algorithm eciency is considered with only big problem sizes. We are not concerned with an exact measurement of an algorithm's efficiency. Terms that do not substantially change the function's magnitude are eliminated.",
            "Time Costing Operations": "The most time consuming: data movement to/from memory/storage. Operations under consideration: Comparisons, Arithmetic operations, Assignments",
            "P and NP Problems": "P: Polynomial (can be solved in polynomial time on a deterministic machine). NP: Nondeterministic Polynomial (can be solved in polynomial time on a nondeterministic machine). NP-complete: NP and every other problem in NP is polynomially reducible to it."
        },
        "Chap 3: Recursion": {
            "Recursion": "Recursion is a repetitive process in which an algorithm calls itself. Direct : A → A. Indirect : A → B → A",
            "Basic components of recursive algorithms": "Two main components of a Recursive Algorithm: 1. Base case (i.e. stopping case). 2. General case (i.e. recursive case)",
            "Properties of all recursive algorithms": "A recursive algorithm solves the large problem by using its solution to a simpler sub-problem. Eventually the sub-problem is simple enough that it can be solved without applying the algorithm to it recursively → This is called the base case.",
            "The Design Methodology": "Every recursive call must either solve a part of the problem or reduce the size of the problem. Rules for designing a recursive algorithm: 1. Determine the base case (stopping case). 2. Then determine the general case (recursive case). 3. Combine the base case and the general cases into an algorithm.",
            "Limitations of Recursion": "A recursive algorithm generally runs more slowly than its nonrecursive implementation. BUT, the recursive solution shorter and more understandable.",
            "Backtracking": "A process to go back to previous steps to try unexplored alternatives."
        },
        "Chap 4: List": {
            "Linear list concepts": "A linear list is a data structure in which each element has a unique successor. Example: Array, Linked list. General list: No restrictions on which operation can be used on the list. No restrictions on where data can be inserted/deleted. Unordered list (random list): Data are not in particular order. Ordered list: data are arranged according to a key. Restricted list: Only some operations can be used on the list. Data can be inserted/deleted only at the ends of the list. Queue: FIFO (First-In-First-Out). Stack: LIFO (Last-In-First-Out).",
            "List ADT": "A list of elements of type T is a nite sequence of elements of T. Basic operations: Construct a list, leaving it empty. Insert an element. Remove an element. Search an element. Retrieve an element. Traverse the list, performing a given operation on each element. Extended operations: Determine whether the list is empty or not. Determine whether the list is full or not. Find the size of the list. Clear the list to make it empty. Replace an element with another element. Merge two ordered list. Append an unordered list to another.",
            "Insertion": "Insert an element at a specied position p in the list. Only with General Unordered List.Any element formerly at position p and all later have their position numbers increased by 1. Insert an element with a given data: With General Unordered List: can be made at any position in the list (at the beginning, in the middle, at the end). With General Ordered List: data must be inserted so that the ordering of the list is maintained (searching appropriate position is needed). With Restricted List: depend on it own denition (FIFO or LIFO).",
            "Removal": "Remove an element at a specied position p in the list. With General Unordered List and General Ordered List. The element at position p is removed from the list, and all subsequent elements have their position numbers decreased by 1.",
            "Retrieval": "Retrieve an element at a specied position p in the list. With General Unordered List and General Ordered List. All elements remain unchanged. ",
            "Success of Basic Operations": "Insertion is successful when the list is not full. Removal, Retrieval are successful when the list is not empty.",
            "Linked List": "A linked list is an ordered collection of data in which each element contains the location of the next element. ",
            "Node": "The elements in a linked list are called nodes. A node in a linked list is a structure that has at least two elds: the data, the address of the next node.",
            "Linked list operations": "Create an empty linked list. Insert a node into a linked list. Delete a node from a linked list. Traverse a linked list. Destroy a linked list",
            "Insert a node into a linked list": "1. Allocate memory for the new node and set up data. 2. Locate the pointer p in the list, which will point to the new node: If the new node becomes the rst element in the List: p is list.head. Otherwise: p is pPre->link, where pPre points to the predecessor of the new node. 3. Point the new node to its successor. 4. Point the pointer p to the new node. Insertion is successful when allocation memory for the new node is successful. There is no dierence between insertion at the beginning of the list and insertion into an empty list.",
            "Delete a node from a linked list": "Locate the pointer p in the list which points to the node to be deleted (pLoc will hold the node to be deleted). If that node is the rst element in the List: p is list.head. Otherwise: p is pPre->link, where pPre points to the predecessor of the node to be deleted. 2. p points to the successor of the node to be deleted. 3. Recycle the memory of the deleted node. Removal is successful when the node to be deleted is found. There is no dierence between deleting the node from the beginning of the list and deleting the only node in the list.",
            "Searching in a linked list": "Sequence Search has to be used for the linked list. Searches a node and returns a pointer to it if found.",
            "Traverse a linked list": "Traverse module controls the loop: calling a user-supplied algorithm to process data"
        },
        "Chap 5: Stack and Queue": {
            "Stack": "A stack of elements of type T is a finite, ordered sequence of elements of T, in which all insertions and deletions are restricted to one end, called the top. Stack is a Last In - First Out (LIFO) data structure. LIFO: The last item put on the stack is the first item that can be taken off.",
            "Basic operations of Stacks": "Construct a stack, leaving it empty. Push an element: put a new element on to the top of the stack. Pop an element: remove the top element from the top of the stack. Top an element: retrieve the top element.",
            "Extended operations:": "Determine whether the stack is empty or not. Determine whether the stack is full or not. Find the size of the stack. Clear the stack to make it empty.",
            "Push data into a Linked Stack": "1 Allocate memory for the new node and set up data. 2 Update pointers: Point the new node to the top node (before adding the new node). Point top to the new node. 3 Update count. Push is successful when allocation memory for the new node is successful. There is no difference between push data into a stack having elements and push data into an empty stack (top having NULL value is assigned to pNew->next: that is corresponding to a list having only one element).",
            "Pop Linked Stack": "1 dltPtr holds the element on the top of the stack. 2 top points to the next element. 3 Recycle dltPtr. Decrease count by 1. Pop is successful when the stack is not empty. There is no difference between pop an element from a stack having elements and pop the only-one element in the stack (dltPtr->next having NULL value is assigned to top: that is corresponding to an empty stack).",
            "Array-based stack implementation": "Implementation of array-based stack is very simple. It uses top variable to point to the topmost stack is element in the array. 1 Initialy top = -1; 2 push operation increases top by one and writes pushed element to storage[top]; 3 pop operation checks that top is not equal to -1 and decreases top variable by 1; 4 getTop operation checks that top is not equal to -1 and returns storage[top]; 5 isEmpty returns boolean if top == -1.",
            "Applications of Stack": "Reversing data items: Reverse a list. Convert Decimal to Binary. Parsing: Brackets Parse. Postponement of processing data items: Infix to Postfix Transformation. Evaluate a Postfix Expression. Backtracking: Goal Seeking Problem. Knight’s Tour. Exiting a Maze. Eight Queens Problem",
            "Queue": "A queue of elements of type T is a finite sequence of elements of T, in which data can only be inserted at one end called the rear, and deleted from the other end called the front. Queue is a First In - First Out (FIFO) data structure. FIFO: The first item stored in the queue is the first item that can be taken out.",
            "Basic operations of Queues": "Construct a queue, leaving it empty. Enqueue: put a new element in to the rear of the queue. Dequeue: remove the first element from the front of the queue. Queue Front: retrieve the front element. Queue Rear: retrieve the rear element.",
            "Applications of Queue": "Polynomial Arithmetic. Categorizing Data. Evaluate a Prefix Expression. Radix Sort. Queue Simulation."
        },
        "Chap 6: Trees": {
            "Basic Tree Concepts": "A tree consists of a finite set of elements, called nodes and a finite set of directed lines, called branches that connect the nodes. Degree of a node is the number of branches associated with the node. Indegree branch is directed branch toward the node. Outdegree branch is directed branch away from the node. The first node is called the root. indegree of the root = 0. Except the root, the indegree of a node = 1. outdegree of a node = 0 or 1 or more. A root is the first node with an indegree of zero. A leaf is any node with an outdegree of zero. A internal node is not a root or a leaf. A parent has an outdegree greater than zero. A child has an indegree of one. a internal node is both a parent of a node and a child of another one. Siblings are two or more nodes with the same parent. For a given node, an ancestor is any node in the path from the root to the node. For a given node, an descendent is any node in the paths from the node to a leaf. A path is a sequence of nodes in which each node is adjacent to the next one. The level of a node is its distance from the root. Siblings are always at the same level. The height of a tree is the level of the leaf in the longest path from the root plus 1. A subtree is any connected structure below the root.",
            "Application of Trees": "Representing hierarchical data. Storing data in a way that makes it easily searchable (ex: binary search tree). Representing sorted lists of data. Network routing algorithms",
            "Binary Trees": "A binary tree node cannot have more than two subtrees.",
            "Binary Tree Properties": "To store N nodes in binary tree: The minimun height: Hmin = [log2N] + 1 or Hmin = [log2(N + 1). The maximum height: Hmax = N. Given a height of the binary tree, H: The minimum number of nodes: Nmin = H, The maximum number of nodes: Nmax = 2^H - 1. The balance factor of a binary tree is the difference in height between its left and right subtrees. Balanced tree: balance factor is 0, -1, or 1 and subtrees are balanced. Complete tree the last level is full. Nearly complete tree Nodes in the last level are on the left.",
            "Binary Tree Structure": "A binary tree is either empty, or it consists of a node called root together with two binary trees called the left and the right subtree of the root.",
            "Binary Tree Traversals": "Depth-first traversal is the processing proceeds along a path from the root through one child to the most distant descendent of that first child before processing a second child, i.e. processes all of the descendents of a child before going on to the next child. Breadth-first traversal is the processing proceeds horizontally from the root to all of its children, then to its children's children, i.e. each level is completely processed before the next level is started.",
            "Preorder traversal (NLR)": "In the preorder traversal, the root is processed first, before the left and right subtrees.",
            "Inorder traversal (LNR)": "In the inorder traversal, the root is processed between its subtrees.",
            "Postorder traversal (LRN)": "In the postorder traversal, the root is processed after its subtrees.",
            "Breadth-First Traversals": "In the breadth-first traversal of a binary tree, we process all of the children of a node before proceeding with the next level.",
            "Expression Trees": "Each leaf is an operand. The root and internal nodes are operators. Sub-trees are sub-expressions",
            "Binary Search Trees": "A binary search tree is a binary tree with the following properties: All items in the left subtree are less than the root. All items in the right subtree are greater than or equal to the root. Each subtree is itself a binary search tree. BST is one of implementations for ordered list. In BST we can search quickly (as with binary search on a contiguous list). In BST we can make insertions and deletions quickly (as with a linked list)."
        },
        "Chap 7: AVL Trees, B-Trees": {
            "AVL Tree Concepts": "AVL Tree is: A Binary Search Tree, in which the heights of the left and right subtrees of the root differ by at most 1, and the left and right subtrees are again AVL trees. AVL Tree is a Binary Search Tree that is balanced tree. A binary tree is an AVL Tree if Each node satisfies BST property: key of the node is greater than the key of each node in its left subtree and is smaller than or equals to the key of each node in its right subtree. Each node satisfies balanced tree property: the difference between the heights of the left subtree and right subtree of the node does not exceed one.",
            "Balancing Trees": "When we insert a node into a tree or delete a node from a tree, the resulting tree may be unbalanced. rebalance the tree. Four unbalanced tree cases: left of left: a subtree of a tree that is left high has also become left high; right of right: a subtree of a tree that is right high has also become right high; right of left: a subtree of a tree that is left high has become right high; left of right: a subtree of a tree that is right high has become left high;",
            "Balancing Trees - Case 1: Left of Left": "Out of balance condition created by a left high subtree of a left high tree. balance the tree by rotating the out of balance node to the right.",
            "Balancing Trees - Case 2: Right of Right": "Out of balance condition created by a right high subtree of a right high tree. balance the tree by rotating the out of balance node to the left.",
            "Balancing Trees - Case 3: Right of Left": "Out of balance condition created by a right high subtree of a left high tree. balance the tree by two steps: rotating the left subtree to the left; rotating the root to the right.",
            "Balancing Trees - Case 4: Left of Right": "Out of balance condition created by a left high subtree of a right high tree. balance the tree by two steps: rotating the right subtree to the right; rotating the root to the left.",
            "AVL Tree Operations": "Search and retrieval are the same for any binary tree. AVL Insert. AVL Delete",
            "Multiway Trees": "Tree whose outdegree is not restricted to 2 while retaining the general properties of binary search trees.",
            "M-Way Search Trees": "Each node has m - 1 data entries and m subtree pointers. The key values in a subtree such that: ≥ the key of the left data entry, < the key of the right data entry.",
            "B-Trees": "A B-tree is an m-way tree with the following additional properties (m ≥ 3): The root is either a leaf or has at least 2 subtrees. All other nodes have at least [m/2] - 1 entries. All leaf nodes are at the same level.",
            "B-Tree Insertion": "Insert the new entry into a leaf node. If the leaf node is overflow, then split it and insert its median entry into its parent.",
            "B-Tree Deletion": "It must take place at a leaf node. If the data to be deleted are not in a leaf node, then replace that entry by the largest entry on its left subtree.",
            "Reflow": "For each node to have sufficient number of entries: Balance: shift data among nodes. Combine: join data from nodes.",
            "B-Tree Variations": "B*Tree: the minimum number of (used) entries is two thirds. B+Tree: Each data entry must be represented at the leaf level. Each leaf node has one additional pointer to move to the next leaf node."
        },
        "Chap 8: Heaps": {
            "Heap Definition": "A heap (max-heap) is a binary tree structure with the following properties: The tree is complete or nearly complete. The key value of each node is greater than or equal to the key value in each of its descendents. A min-heap is a binary tree structure with the following properties: The tree is complete or nearly complete. The key value of each node is less than or equal to the key value in each of its descendents.",
            "ReheapUp": "The reheapUp operation repairs a broken heap by floating the last element up the tree until it is in its correct location in the heap.",
            "ReheapDown": "The reheapDown operation repairs a broken heap by pushing the root down the tree until it is in its correct location in the heap.",
            "Properties of Heaps": "A complete or nearly complete binary tree. If the height is h, the number of nodes N is betwween 2^(h-1) and 2^h - 1. Complete tree: N = 2^h - 1 when last level is full. Nearly complete: All nodes in the last level are on the left.Heap can be represented in an array.",
            "Build a Heap": "Given a filled array of elements in random order, to build the heap we need to rearrange the data so that each node in the heap is greater than its children. We begin by dividing the array into two parts, the left being a heap and the right being data to be inserted into the heap. Note the wall between the first and second parts. At the beginning the root (the first node) is the only node in the heap and the rest of the array are data to be inserted. Each iteration of the insertion algorithm uses reheap up to insert the next element into the heap and moves the wall separating the elements one position to the right.",
            "Insert a Node into a Heap": "To insert a node, we need to locate the first empty leaf in the array. We find it immediately after the last node in the tree, which is given as a parameter. To insert a node, we move the new data to the first empty leaf and reheap up.",
            "Delete a Node from a Heap": "When deleting a node from a heap, the most common and meaningful logic is to delete the root. After it has been deleted, the heap is thus left without a root. To reestablish the heap, we move the data in the last heap node to the root and reheap down.",
            "Heap Applications": "Three common applications of heaps are: selection algorithms, priority queues, and sorting.",
            "Selection Algorithms": "Determining the kth element in an unsorted list. Two solutions: Sort the list and select the element at location k. The complexity of a simple sorting algorithm is O(n^2). Create a heap and delete k - 1 elements from the heap, leaving the desired element at the top. Rather than simply discarding the elements at the top of the heap, a better solution would be to place the deleted element at the end of the heap and reduce the heap size by 1. After the kth element has been processed, the temporarily removed elements can then be inserted into the heap.",
            "Priority Queues": "The heap is an excellent structure to use for a priority queue. Assume that we have a priority queue with three priorities: high (3), medium (2), and low (1). Of the first five customers who arrive, the second and the fifth are high-priority customers, the third is medium priority, and the first and the fourth are low priority."
        },
        "Chap 9: Sorting": {
            "Sorting concepts": "One of the most important concepts and common applications in computing. Sort stability: data with equal keys maintain their relative input order in the output. Sort efficiency: a measure of the relative efficiency of a sort = number of comparisons + number of moves.",
            "Straight Insertion Sort": "The list is divided into two parts: sorted and unsorted. In each pass, the first element of the unsorted sublist is inserted into the sorted sublist.",
            "Shell Sort": "Given a list of N elements, the list is divided into K segments (K is called the increment). Each segment contains N/K or more elements. Segments are dispersed throughout the list. Also is called diminishing-increment sort. For the value of K in each iteration, sort the K segments. After each iteration, K is reduced until it is 1 in the final iteration. From more of the comparisons, it is better when we can receive more new information. Incremental values should not be multiples of each other, other wise, the same keys compared on one pass would be compared again at the next. The final incremental value must be 1.",
            "Selection Sort": "In each pass, the smallest/largest item is selected and placed in a sorted list.",
            "Straight Selection Sort": "The list is divided into two parts: sorted and unsorted. In each pass, in the unsorted sublist, the smallest element is selected and exchanged with the first element.",
            "Heap Sort": "The unsorted sublist is organized into a heap.In each pass, in the unsorted sublist, the largest element is selected and exchanged with the last element. The the heap is reheaped.",
            "Exchange Sort": "In each pass, elements that are out of order are exchanged, until the entire list is sorted. Exchange is extensively used.",
            "Bubble Sort": "The list is divided into two parts: sorted and unsorted. In each pass, the smallest element is bubbled from the unsorted sublist and moved to the sorted sublist.",
            "Quick Sort": "Given a pivot value, the partition rearranges the entries in the list as the following figure.",
            "Merge Sort": "Algorithm MergeSort() Sorts the linked list using merge sort. recursiveMergeSort(head) End MergeSort. "
        }
    }
}