{
    "Data Structures and Algorithms": {
        "Chap 1: Introduction": {
            "What is Data?": "Data is information that has been translated into a form that is more convenient to calculate, analyze. Qualitative data: descriptive information, Quantitative data: numerical information (numbers). Discrete data can only take certain values (like whole numbers). Continuous data can take any value (within a range)",
            "Data Type": "Class of data objects that have the same properties. 1. A set of values. 2. A set of operations on values. Type: Integer, Floating point, character,...",
            "Data Stuctures": "What is a data structure? 1. A combination of elements in which each is either a data type or another data structure. 2. A set of associations or relationships (structure) that holds the data together.",
            "Abstract data type": "The concept of abstraction: Users know what a data type can do. How it is done is hidden. Denition: An abstract data type is a data declaration packaged together with the operations that are meaningful for the data type. 1. Declaration of data. 2. Declaration of operations. 3. Encapsulation of data and operations",
            "Algorithm": "What is an algorithm? The logical steps to solve a problem. What is a program? Program = Data structures + Algorithms.",
            "Pseudocode": "The most common tool to dene algorithms. English-like representation of the algorithm logic. Pseudocode = English + code. English: relaxed syntax being easy to read. Code: instructions using basic control structures (sequential, conditional, iterative). Algorithm Header: Name, Parameters and their types. Purpose: what the algorithm does. Precondition: precursor requirements for the parameters. Postcondition: taken action and status of the parameters. Return condition: returned value. Algorithm Body: Statements. Statement numbers: decimal notation to express levels. Variables: important data. Algorithm analysis: comments to explain salient points. Statement constructs: sequence, selection, iteration.",
            "Pointers": "A pointer is a variable whose value is the address of another variable, i.e., direct address of the memory location. Address-of operator (&): The address of a variable can be obtained by preceding the name of a variable with an ampersand sign (&), known as address-of operator. Dereference operator (*): To access the variable pointed to by a pointer, we precede the pointer name with the dereference operator (*).",
            "Arrays": "An array is a series of elements of the same type placed in contiguous memory locations that can be individually referenced by a unique identier with an index.",
            "Pointers and arrays": "The concept of arrays is related to that of pointers. Arrays work very much like pointers to their rst elements, and, actually, an array can always be implicitly converted to the pointer of the proper type."
        },
        "Chap 2: Algorithm Complexity": {
            "Algorithm Eciency": "A problem often has many algorithms. Comparing two dierent algorithms ⇒ Computational complexity: measure of the diculty degree (time and/or space) of an algorithm. How fast an algorithm is? How much memory does it cost? General format eciency = f(n), n is the size of a problem (the key number that determines the size of input data)",
            "Asymptotic Complexity": "Algorithm eciency is considered with only big problem sizes. We are not concerned with an exact measurement of an algorithm's efficiency. Terms that do not substantially change the function's magnitude are eliminated.",
            "Time Costing Operations": "The most time consuming: data movement to/from memory/storage. Operations under consideration: Comparisons, Arithmetic operations, Assignments",
            "P and NP Problems": "P: Polynomial (can be solved in polynomial time on a deterministic machine). NP: Nondeterministic Polynomial (can be solved in polynomial time on a nondeterministic machine). NP-complete: NP and every other problem in NP is polynomially reducible to it."
        },
        "Chap 3: Recursion": {
            "Recursion": "Recursion is a repetitive process in which an algorithm calls itself. Direct : A → A. Indirect : A → B → A",
            "Basic components of recursive algorithms": "Two main components of a Recursive Algorithm: 1. Base case (i.e. stopping case). 2. General case (i.e. recursive case)",
            "Properties of all recursive algorithms": "A recursive algorithm solves the large problem by using its solution to a simpler sub-problem. Eventually the sub-problem is simple enough that it can be solved without applying the algorithm to it recursively → This is called the base case.",
            "The Design Methodology": "Every recursive call must either solve a part of the problem or reduce the size of the problem. Rules for designing a recursive algorithm: 1. Determine the base case (stopping case). 2. Then determine the general case (recursive case). 3. Combine the base case and the general cases into an algorithm.",
            "Limitations of Recursion": "A recursive algorithm generally runs more slowly than its nonrecursive implementation. BUT, the recursive solution shorter and more understandable.",
            "Backtracking": "A process to go back to previous steps to try unexplored alternatives."
        },
        "Chap 4: List": {
            "Linear list concepts": "A linear list is a data structure in which each element has a unique successor. Example: Array, Linked list. General list: No restrictions on which operation can be used on the list. No restrictions on where data can be inserted/deleted. Unordered list (random list): Data are not in particular order. Ordered list: data are arranged according to a key. Restricted list: Only some operations can be used on the list. Data can be inserted/deleted only at the ends of the list. Queue: FIFO (First-In-First-Out). Stack: LIFO (Last-In-First-Out).",
            "List ADT": "A list of elements of type T is a nite sequence of elements of T. Basic operations: Construct a list, leaving it empty. Insert an element. Remove an element. Search an element. Retrieve an element. Traverse the list, performing a given operation on each element. Extended operations: Determine whether the list is empty or not. Determine whether the list is full or not. Find the size of the list. Clear the list to make it empty. Replace an element with another element. Merge two ordered list. Append an unordered list to another.",
            "Insertion": "Insert an element at a specied position p in the list. Only with General Unordered List.Any element formerly at position p and all later have their position numbers increased by 1. Insert an element with a given data: With General Unordered List: can be made at any position in the list (at the beginning, in the middle, at the end). With General Ordered List: data must be inserted so that the ordering of the list is maintained (searching appropriate position is needed). With Restricted List: depend on it own denition (FIFO or LIFO).",
            "Removal": "Remove an element at a specied position p in the list. With General Unordered List and General Ordered List. The element at position p is removed from the list, and all subsequent elements have their position numbers decreased by 1.",
            "Retrieval": "Retrieve an element at a specied position p in the list. With General Unordered List and General Ordered List. All elements remain unchanged. ",
            "Success of Basic Operations": "Insertion is successful when the list is not full. Removal, Retrieval are successful when the list is not empty.",
            "Linked List": "A linked list is an ordered collection of data in which each element contains the location of the next element. ",
            "Node": "The elements in a linked list are called nodes. A node in a linked list is a structure that has at least two elds: the data, the address of the next node.",
            "Linked list operations": "Create an empty linked list. Insert a node into a linked list. Delete a node from a linked list. Traverse a linked list. Destroy a linked list",
            "Insert a node into a linked list": "1. Allocate memory for the new node and set up data. 2. Locate the pointer p in the list, which will point to the new node: If the new node becomes the rst element in the List: p is list.head. Otherwise: p is pPre->link, where pPre points to the predecessor of the new node. 3. Point the new node to its successor. 4. Point the pointer p to the new node. Insertion is successful when allocation memory for the new node is successful. There is no dierence between insertion at the beginning of the list and insertion into an empty list.",
            "Delete a node from a linked list": "Locate the pointer p in the list which points to the node to be deleted (pLoc will hold the node to be deleted). If that node is the rst element in the List: p is list.head. Otherwise: p is pPre->link, where pPre points to the predecessor of the node to be deleted. 2. p points to the successor of the node to be deleted. 3. Recycle the memory of the deleted node. Removal is successful when the node to be deleted is found. There is no dierence between deleting the node from the beginning of the list and deleting the only node in the list.",
            "Searching in a linked list": "Sequence Search has to be used for the linked list. Searches a node and returns a pointer to it if found.",
            "Traverse a linked list": "Traverse module controls the loop: calling a user-supplied algorithm to process data"
        },
        "Chap 5: Stack and Queue": {
            "Stack": "A stack of elements of type T is a finite, ordered sequence of elements of T, in which all insertions and deletions are restricted to one end, called the top. Stack is a Last In - First Out (LIFO) data structure. LIFO: The last item put on the stack is the first item that can be taken off.",
            "Basic operations of Stacks": "Construct a stack, leaving it empty. Push an element: put a new element on to the top of the stack. Pop an element: remove the top element from the top of the stack. Top an element: retrieve the top element.",
            "Extended operations:": "Determine whether the stack is empty or not. Determine whether the stack is full or not. Find the size of the stack. Clear the stack to make it empty.",
            "Push data into a Linked Stack": "1 Allocate memory for the new node and set up data. 2 Update pointers: Point the new node to the top node (before adding the new node). Point top to the new node. 3 Update count. Push is successful when allocation memory for the new node is successful. There is no difference between push data into a stack having elements and push data into an empty stack (top having NULL value is assigned to pNew->next: that is corresponding to a list having only one element).",
            "Pop Linked Stack": "1 dltPtr holds the element on the top of the stack. 2 top points to the next element. 3 Recycle dltPtr. Decrease count by 1. Pop is successful when the stack is not empty. There is no difference between pop an element from a stack having elements and pop the only-one element in the stack (dltPtr->next having NULL value is assigned to top: that is corresponding to an empty stack).",
            "Array-based stack implementation": "Implementation of array-based stack is very simple. It uses top variable to point to the topmost stack is element in the array. 1 Initialy top = -1; 2 push operation increases top by one and writes pushed element to storage[top]; 3 pop operation checks that top is not equal to -1 and decreases top variable by 1; 4 getTop operation checks that top is not equal to -1 and returns storage[top]; 5 isEmpty returns boolean if top == -1.",
            "Applications of Stack": "Reversing data items: Reverse a list. Convert Decimal to Binary. Parsing: Brackets Parse. Postponement of processing data items: Infix to Postfix Transformation. Evaluate a Postfix Expression. Backtracking: Goal Seeking Problem. Knight’s Tour. Exiting a Maze. Eight Queens Problem",
            "Queue": "A queue of elements of type T is a finite sequence of elements of T, in which data can only be inserted at one end called the rear, and deleted from the other end called the front. Queue is a First In - First Out (FIFO) data structure. FIFO: The first item stored in the queue is the first item that can be taken out.",
            "Basic operations of Queues": "Construct a queue, leaving it empty. Enqueue: put a new element in to the rear of the queue. Dequeue: remove the first element from the front of the queue. Queue Front: retrieve the front element. Queue Rear: retrieve the rear element.",
            "Applications of Queue": "Polynomial Arithmetic. Categorizing Data. Evaluate a Prefix Expression. Radix Sort. Queue Simulation."
        }
    }
}